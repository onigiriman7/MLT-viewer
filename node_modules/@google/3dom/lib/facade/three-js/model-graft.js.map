{"version":3,"file":"model-graft.js","sourceRoot":"","sources":["../../../src/facade/three-js/model-graft.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;;AAMH,OAAO,EAAC,KAAK,EAAC,MAAM,YAAY,CAAC;AAGjC,MAAM,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;AAC/B,MAAM,qBAAqB,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC;AAC7D,MAAM,qBAAqB,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC;AAE7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AACH,MAAM,OAAO,UAAW,SAAQ,WAAW;IAMzC,YAAY,QAAgB,EAAE,oBAA0C;QACtE,KAAK,EAAE,CAAC;QAHH,QAAuB,GAAG,IAAI,GAAG,EAA2B,CAAC;QAIlE,IAAI,CAAC,qBAAqB,CAAC,GAAG,oBAAoB,CAAC;QACnD,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,oBAAoB,CAAC,CAAC;IACjE,CAAC;IAED,IAAI,oBAAoB;QACtB,OAAO,IAAI,CAAC,qBAAqB,CAAC,CAAC;IACrC,CAAC;IAED,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;IACtB,CAAC;IAED,sBAAsB,CAAC,EAAU;QAC/B,MAAM,OAAO,GAAG,IAAI,CAAC,qBAAqB,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAEpD,IAAI,OAAO,IAAI,IAAI,EAAE;YACnB,OAAO,IAAI,CAAC;SACb;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,OAAwB;QAC5B,IAAI,CAAC,qBAAqB,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IAC/D,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,EAAU,EAAE,QAAgB,EAAE,KAAc;QACvD,mEAAmE;QACnE,mEAAmE;QACnE,uEAAuE;QACvE,MAAM,OAAO,GAAG,IAAI,CAAC,sBAAsB,CAAC,EAAE,CAAC,CAAC;QAEhD,IAAI,OAAO,IAAI,IAAI,EAAE;YACnB,MAAM,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YAEtC,IAAI,CAAC,aAAa,CACd,IAAI,WAAW,CAAC,UAAU,EAAE,EAAC,MAAM,EAAE,EAAC,OAAO,EAAE,OAAO,EAAC,EAAC,CAAC,CAAC,CAAC;SAChE;IACH,CAAC;CACF;KA3CS,qBAAqB","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport {ModelGraft as ModelGraftInterface} from '../api.js';\n\nimport {CorrelatedSceneGraph} from './correlated-scene-graph.js';\nimport {Model} from './model.js';\nimport {ThreeDOMElement} from './three-dom-element.js';\n\nconst $model = Symbol('model');\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\nconst $elementsByInternalId = Symbol('elementsByInternalId');\n\n/**\n * ModelGraft\n *\n * This is a coordination primitive between a scene graph as represented by the\n * output for Three.js' GLTFLoader and a counterpart 3DOM facade. Since this is\n * the Three.js-specific implementation of the facade, the input is a GLTF-like\n * object whose keys refer to Three.js-specific constructs (e.g., gltf.scene is\n * a THREE.Scene).\n *\n * When created, the ModelGraft produces a Model that can be traversed and\n * manipulated to mutate the Three.js scene graph synchronously (but\n * indirectly). The benefit of this is that mutations to the Three.js scene can\n * be performed in a Three.js-agnostic fashion that is potentially portable to\n * alternative rendering backends.\n *\n * The scene graph representation produced by the ModelGraft is designed to\n * match the structures described in the glTF 2.0 spec as closely as possible.\n * Where there are deviations, it is usually for the purpose of making\n * synchronization easier, or else for ergonomics. For example, in glTF 2.0, the\n * graph is a series of flat arrays where nodes cross-reference each other by\n * index to represent hierarchy, but in a Model nodes have array members\n * containing refrences to their hierarchical children.\n *\n * An important goal of ModelGraft is to enable a scene in one JavaScript\n * context to be manipulated by script in a remote context, such as a distant\n * worker thread or even a different process. So, every node in the graph\n * is able to be serialized, and the serialized form includes an ID that is\n * locally unique to the ModelGraft instance that the node came from so that\n * the remote context can refer back to it. A ModelGraft can be thought of as\n * the host execution context counterpart to the ModelKernel in the scene graph\n * execution context.\n */\nexport class ModelGraft extends EventTarget implements ModelGraftInterface {\n  private[$model]: Model;\n  private[$correlatedSceneGraph]: CorrelatedSceneGraph;\n\n  private[$elementsByInternalId] = new Map<number, ThreeDOMElement>();\n\n  constructor(modelUri: string, correlatedSceneGraph: CorrelatedSceneGraph) {\n    super();\n    this[$correlatedSceneGraph] = correlatedSceneGraph;\n    this[$model] = new Model(this, modelUri, correlatedSceneGraph);\n  }\n\n  get correlatedSceneGraph() {\n    return this[$correlatedSceneGraph];\n  }\n\n  get model() {\n    return this[$model];\n  }\n\n  getElementByInternalId(id: number): ThreeDOMElement|null {\n    const element = this[$elementsByInternalId].get(id);\n\n    if (element == null) {\n      return null;\n    }\n\n    return element;\n  }\n\n  adopt(element: ThreeDOMElement) {\n    this[$elementsByInternalId].set(element.internalID, element);\n  }\n\n  async mutate(id: number, property: string, value: unknown) {\n    // TODO(#1005): Manipulations probably need to be validated against\n    // allowed capabilities here. We already do this on the scene graph\n    // execution context side, but it would be safer to do it on both sides\n    const element = this.getElementByInternalId(id);\n\n    if (element != null) {\n      await element.mutate(property, value);\n\n      this.dispatchEvent(\n          new CustomEvent('mutation', {detail: {element: element}}));\n    }\n  }\n}\n"]}